{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Foundation and Authentication",
        "description": "Initialize Next.js project with TypeScript and integrate Clerk authentication with social login options",
        "details": "Create Next.js 14+ project with TypeScript, ESLint, and Tailwind CSS. Install and configure Clerk authentication with Google, GitHub, and LinkedIn social providers. Set up environment variables for Clerk keys. Create authentication middleware and protected route patterns. Implement user registration/login flows with proper error handling and redirects.",
        "testStrategy": "Test social login flows for each provider, verify JWT token generation, test protected route access, and validate user session persistence across browser refreshes",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js Project with TypeScript and Core Dependencies",
            "description": "Create a new Next.js 14+ project with TypeScript, ESLint, and Tailwind CSS configuration",
            "dependencies": [],
            "details": "Run 'npx create-next-app@latest' with TypeScript and Tailwind CSS options. Configure ESLint for TypeScript. Set up project structure with proper TypeScript configuration in tsconfig.json. Install additional dependencies like @types/node. Verify the development server runs correctly.",
            "status": "done",
            "testStrategy": "Verify project builds without errors and development server starts successfully"
          },
          {
            "id": 2,
            "title": "Install and Configure Clerk Authentication Package",
            "description": "Install Clerk authentication package and set up basic configuration with environment variables",
            "dependencies": [
              1
            ],
            "details": "Install @clerk/nextjs package. Create .env.local file with NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY and CLERK_SECRET_KEY placeholders. Configure Clerk provider in app layout or _app.tsx. Set up basic Clerk configuration object with domain and appearance settings.",
            "status": "done",
            "testStrategy": "Verify Clerk package imports correctly and environment variables are properly loaded"
          },
          {
            "id": 3,
            "title": "Configure Social Login Providers",
            "description": "Set up Google, GitHub, and LinkedIn OAuth applications and configure them in Clerk dashboard",
            "dependencies": [
              2
            ],
            "details": "Create OAuth applications in Google Cloud Console, GitHub Developer Settings, and LinkedIn Developer Portal. Configure redirect URLs for each provider. Add social provider configurations in Clerk dashboard. Update environment variables with OAuth client IDs and secrets. Configure social login options in Clerk settings.",
            "status": "done",
            "testStrategy": "Test social login flows manually through Clerk's development environment"
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware and Route Protection",
            "description": "Create Next.js middleware for authentication and set up protected route patterns",
            "dependencies": [
              3
            ],
            "details": "Create middleware.ts file in project root. Implement Clerk's authMiddleware to protect routes. Define public and private route patterns. Set up redirect logic for unauthenticated users. Configure middleware matcher for specific route patterns. Create higher-order component or hook for client-side route protection.",
            "status": "done",
            "testStrategy": "Test route protection by accessing protected routes without authentication and verify proper redirects"
          },
          {
            "id": 5,
            "title": "Build User Registration and Login Flow Components",
            "description": "Create authentication UI components with proper error handling and user flow management",
            "dependencies": [
              4
            ],
            "details": "Create SignIn and SignUp components using Clerk's pre-built components or custom implementations. Implement error handling for authentication failures. Set up post-authentication redirects to appropriate pages. Create user profile management components. Add loading states and proper UX feedback. Implement sign-out functionality.",
            "status": "done",
            "testStrategy": "Test complete user flows including registration, login, profile access, and logout with various error scenarios"
          }
        ]
      },
      {
        "id": 2,
        "title": "Setup Supabase Database and Schema",
        "description": "Configure Supabase PostgreSQL database with complete schema for companies, users, and artifacts",
        "details": "Set up Supabase project and configure database connection. Create companies table with YC data fields (id, yc_id, name, batch, stage, team_size, is_ai_related, spearfish_score, github_repos, huggingface_models, etc.). Create user_profiles table synced with Clerk user data. Create artifacts table for templates and completions. Set up RLS policies, indexes for performance, and real-time subscriptions. Configure database migrations and seed data.",
        "testStrategy": "Test database connections, verify table creation and constraints, test RLS policies with different user roles, validate data integrity and foreign key relationships",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Supabase Project and Database Connection",
            "description": "Create new Supabase project, configure environment variables, and establish database connection in the Next.js application",
            "dependencies": [],
            "details": "Create a new Supabase project through the dashboard. Set up environment variables (.env.local) with NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY. Install @supabase/supabase-js and create a Supabase client instance in src/lib/supabase.ts. Configure the client with proper TypeScript types and authentication settings. Test the connection by running a simple query.",
            "status": "done",
            "testStrategy": "Create a simple API route that tests database connectivity by running a basic SELECT query. Verify environment variables are properly loaded and the Supabase client initializes without errors."
          },
          {
            "id": 2,
            "title": "Create Core Database Tables (Companies, Users, Artifacts)",
            "description": "Design and create the main database tables with proper column definitions, primary keys, and foreign key relationships",
            "dependencies": [
              1
            ],
            "details": "Create companies table with columns: id (uuid), yc_id (text unique), name (text), batch (text), stage (text), team_size (integer), is_ai_related (boolean), spearfish_score (numeric), github_repos (jsonb), huggingface_models (jsonb), website_url (text), description (text), created_at (timestamp), updated_at (timestamp). Create user_profiles table: id (uuid), clerk_user_id (text unique), email (text), full_name (text), company_id (uuid references companies), role (text), created_at, updated_at. Create artifacts table: id (uuid), company_id (uuid references companies), created_by (uuid references user_profiles), type (text), title (text), content (jsonb), metadata (jsonb), is_template (boolean), parent_artifact_id (uuid self-reference), created_at, updated_at.",
            "status": "done",
            "testStrategy": "Write migration scripts that can be rolled back. Test table creation in a development environment first. Verify all foreign key constraints work correctly by inserting test data with proper relationships."
          },
          {
            "id": 3,
            "title": "Implement Row Level Security (RLS) Policies",
            "description": "Configure comprehensive RLS policies to ensure data security and proper access control based on user authentication and company membership [Updated: 7/11/2025]",
            "dependencies": [
              2
            ],
            "details": "Enable RLS on all tables. For companies table: allow public read for basic info, restrict write to company admins. For user_profiles: users can read/update their own profile, company members can view teammates. For artifacts: implement policies based on company membership - users can CRUD their company's artifacts, read public templates. Create helper functions in PostgreSQL for checking user permissions. Set up service role key for admin operations. Configure policies to work with Clerk JWT claims.\n<info added on 2025-07-12T01:26:07.085Z>\nI cannot generate new content to append to this subtask based on the request \"Show current implementation notes and progress\". This request is asking to view existing information, not to add new content. The subtask already contains implementation details about RLS policies, and there's no new information to add without actual implementation work being done or reported.\n</info added on 2025-07-12T01:26:07.085Z>",
            "status": "done",
            "testStrategy": "Create test scenarios for different user roles and permissions. Verify that users can only access their company's data. Test that public templates are readable by all authenticated users. Ensure service role bypasses RLS for admin operations."
          },
          {
            "id": 4,
            "title": "Create Database Indexes and Optimize Performance",
            "description": "Design and implement strategic indexes for query performance, configure real-time subscriptions, and optimize for common access patterns",
            "dependencies": [
              3
            ],
            "details": "Create indexes on: companies(yc_id), companies(batch), companies(is_ai_related), user_profiles(clerk_user_id), user_profiles(company_id), artifacts(company_id, type), artifacts(is_template), artifacts(created_by). Set up composite indexes for common query patterns. Configure btree indexes for sorting operations on created_at/updated_at. Create GIN indexes on JSONB columns (github_repos, huggingface_models, content) for efficient JSON queries. Enable real-time subscriptions on artifacts table for live updates. Configure connection pooling settings.",
            "status": "done",
            "testStrategy": "Use EXPLAIN ANALYZE to verify index usage in common queries. Benchmark query performance before and after index creation. Test real-time subscriptions with multiple concurrent connections."
          },
          {
            "id": 5,
            "title": "Setup Database Migrations and Seed Data",
            "description": "Implement a robust migration system for schema versioning and create comprehensive seed data for development and testing",
            "dependencies": [
              4
            ],
            "details": "Set up Supabase migrations using the CLI (supabase/migrations folder). Create numbered migration files for each schema change. Implement seed.sql with sample YC companies data including realistic spearfish_scores, GitHub repos, and HuggingFace models. Create template artifacts for common use cases (pitch decks, product roadmaps, technical documentation). Set up npm scripts for running migrations: 'db:migrate', 'db:reset', 'db:seed'. Document migration procedures in README. Create a migration for Clerk webhook integration to sync user data.",
            "status": "done",
            "testStrategy": "Test migrations on a fresh database to ensure they run in correct order. Verify seed data creates valid relationships between tables. Test rollback procedures for each migration. Ensure development environment can be quickly reset with fresh seed data."
          },
          {
            "id": 6,
            "title": "Create Supabase project and configure database connection",
            "description": "Set up new Supabase project, obtain connection strings, and configure environment variables for database access",
            "dependencies": [],
            "details": "Create Supabase account/project, get database URL and anon key, set up .env.local with SUPABASE_URL and SUPABASE_ANON_KEY, install @supabase/supabase-js client library, create initial database connection utility",
            "status": "done",
            "testStrategy": "Test database connection by running a simple query to verify connectivity and authentication"
          },
          {
            "id": 7,
            "title": "Design and create companies table schema",
            "description": "Create comprehensive companies table with YC data fields and appropriate data types",
            "dependencies": [
              6
            ],
            "details": "Create companies table with fields: id (uuid primary key), yc_id (text unique), name (text), batch (text), stage (text), team_size (integer), is_ai_related (boolean), spearfish_score (numeric), github_repos (jsonb), huggingface_models (jsonb), website_url (text), description (text), created_at/updated_at timestamps",
            "status": "done",
            "testStrategy": "Insert sample company data and verify all fields accept correct data types, test unique constraints on yc_id"
          },
          {
            "id": 8,
            "title": "Create user_profiles table with Clerk integration",
            "description": "Set up user_profiles table that syncs with Clerk authentication data",
            "dependencies": [
              6
            ],
            "details": "Create user_profiles table with fields: id (uuid primary key), clerk_user_id (text unique), email (text), first_name (text), last_name (text), profile_image_url (text), created_at/updated_at timestamps. Set up triggers or webhooks for Clerk user sync",
            "status": "done",
            "testStrategy": "Test user profile creation on Clerk signup, verify data synchronization between Clerk and Supabase"
          },
          {
            "id": 9,
            "title": "Design and implement artifacts table schema",
            "description": "Create artifacts table for storing templates and completions with proper relationships",
            "dependencies": [
              7,
              8
            ],
            "details": "Create artifacts table with fields: id (uuid primary key), user_id (uuid foreign key to user_profiles), company_id (uuid foreign key to companies), type (enum: template/completion), title (text), content (text), metadata (jsonb), is_public (boolean), created_at/updated_at timestamps",
            "status": "done",
            "testStrategy": "Test artifact creation, verify foreign key relationships work correctly, test different artifact types"
          },
          {
            "id": 10,
            "title": "Configure RLS policies, indexes, and real-time subscriptions",
            "description": "Set up Row Level Security policies, performance indexes, and real-time features",
            "dependencies": [
              7,
              8,
              9
            ],
            "details": "Create RLS policies for secure data access (users can only access their own data), add indexes on frequently queried fields (yc_id, user_id, company_id, created_at), enable real-time subscriptions for artifacts table, set up database migrations structure",
            "status": "done",
            "testStrategy": "Test RLS policies with different user scenarios, verify query performance with indexes, test real-time updates in application"
          }
        ]
      },
      {
        "id": 3,
        "title": "Y Combinator API Integration with AI Company Classification",
        "description": "Integrate YC API to fetch all companies and implement AI classification system for target batches",
        "details": "Build YC API integration to fetch companies from W22, S22, W23 batches. Implement AI classification using OpenAI GPT-4 to identify AI-related companies based on descriptions and industry tags. Create data sync jobs to update company information daily. Store classified companies in Supabase with AI-related flag. Handle API rate limiting and error scenarios gracefully.",
        "testStrategy": "Test API integration with YC endpoints, validate AI classification accuracy on sample companies, test data synchronization and duplicate handling, verify error handling for API failures",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Y Combinator API client and authentication",
            "description": "Create API client for Y Combinator's public API with proper authentication and base configuration",
            "dependencies": [],
            "details": "Research YC's public API endpoints and authentication requirements. Create a dedicated API client class with proper error handling, request/response typing, and configuration management. Set up environment variables for API credentials if required.",
            "status": "done",
            "testStrategy": "Unit tests for API client initialization, authentication flow, and basic connectivity. Mock API responses for consistent testing."
          },
          {
            "id": 2,
            "title": "Implement company data fetching for target batches",
            "description": "Build functions to fetch company data from W22, S22, and W23 batches with rate limiting and pagination",
            "dependencies": [
              1
            ],
            "details": "Implement batch-specific data fetching with proper pagination handling. Add rate limiting to respect API quotas. Include retry logic with exponential backoff for failed requests. Parse and validate company data structure including name, description, industry, batch info.",
            "status": "done",
            "testStrategy": "Integration tests with YC API (using test data). Unit tests for pagination, rate limiting, and error handling scenarios."
          },
          {
            "id": 3,
            "title": "Develop AI classification system using OpenAI GPT-4",
            "description": "Create AI-powered classification to identify AI-related companies based on descriptions and industry tags",
            "dependencies": [],
            "details": "Design classification prompts for GPT-4 to analyze company descriptions and determine AI relevance. Include classification criteria for various AI domains (ML, computer vision, NLP, etc.). Implement confidence scoring and result validation. Handle edge cases and ambiguous classifications.",
            "status": "done",
            "testStrategy": "Test with known AI companies for accuracy validation. Unit tests for prompt construction and response parsing. Performance tests for classification speed."
          },
          {
            "id": 4,
            "title": "Build Supabase database schema and data storage layer",
            "description": "Design and implement database schema for storing YC companies with AI classification flags and metadata",
            "dependencies": [],
            "details": "Create companies table with fields for YC data (name, description, batch, industry) and AI classification results (is_ai_related, confidence_score, classification_date). Implement data access layer with CRUD operations. Add indexes for efficient querying and filtering.",
            "status": "done",
            "testStrategy": "Database integration tests for schema creation and data operations. Test data integrity constraints and query performance."
          },
          {
            "id": 5,
            "title": "Implement daily sync job with error handling and monitoring",
            "description": "Create automated daily sync process to update company data and classifications with comprehensive error handling",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Build scheduled job to fetch latest YC data, run AI classifications, and update database. Implement comprehensive error handling for API failures, AI service issues, and database problems. Add logging and monitoring for sync status tracking. Include data deduplication and conflict resolution.",
            "status": "done",
            "testStrategy": "End-to-end testing of sync process. Error scenario testing (API down, AI service timeout, database issues). Performance testing for large data volumes."
          }
        ]
      },
      {
        "id": 4,
        "title": "Spearfish Scoring Algorithm Implementation",
        "description": "Implement comprehensive weighted scoring system based on spearfishing methodology criteria",
        "details": "Create spearfish scoring algorithm with weighted criteria: Heavy weight (W22/S22/W23 batches), High weight (18-24 months age, Series A stage), Medium weight (GitHub star growth >1K/month, B2B focus, HuggingFace activity >100K downloads), Low weight (conference presence, boring names, hiring status). Implement score calculation function (0-100) and daily recalculation job. Store scores in database with timestamp tracking.",
        "testStrategy": "Test scoring algorithm with known company data, validate weight calculations, test score updates with changing data, verify score distribution across company dataset",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Document Scoring Criteria and Weights",
            "description": "Identify and clearly document all spearfishing methodology criteria and assign appropriate weights (heavy, high, medium, low) as specified for each batch, age, stage, and activity metric.",
            "dependencies": [],
            "details": "Ensure criteria are specific, measurable, and aligned with project goals. Collaborate with stakeholders to confirm accuracy and completeness of the criteria and their weights.",
            "status": "done",
            "testStrategy": "Review documentation with stakeholders and verify that all required criteria and weights are present and unambiguous."
          },
          {
            "id": 2,
            "title": "Design Scoring Calculation Logic",
            "description": "Develop the algorithm to calculate a composite score (0-100) for each entity based on the defined weighted criteria.",
            "dependencies": [
              1
            ],
            "details": "Implement logic to multiply each criterion's score by its weight, sum the results, and normalize to a 0-100 scale. Ensure the algorithm can handle missing or partial data gracefully.",
            "status": "done",
            "testStrategy": "Unit test the calculation logic with sample data sets to verify correct weighted scoring and normalization."
          },
          {
            "id": 3,
            "title": "Implement Score Calculation Function",
            "description": "Code the function that takes entity data as input and outputs the calculated spearfish score using the designed algorithm.",
            "dependencies": [
              2
            ],
            "details": "Develop the function in the target programming language, ensuring it is modular, testable, and efficient. Include error handling for invalid or incomplete input.",
            "status": "done",
            "testStrategy": "Write automated tests to validate function output against expected scores for a variety of input scenarios."
          },
          {
            "id": 4,
            "title": "Develop Daily Score Recalculation Job",
            "description": "Create a scheduled job that recalculates scores for all entities daily and updates the results.",
            "dependencies": [
              3
            ],
            "details": "Implement a job scheduler (e.g., cron, cloud scheduler) to trigger the score calculation function for all relevant entities every 24 hours.",
            "status": "done",
            "testStrategy": "Simulate daily runs in a test environment and verify that all entities are recalculated and updated as expected."
          },
          {
            "id": 5,
            "title": "Store Scores with Timestamp Tracking in Database",
            "description": "Design and implement database schema and logic to store calculated scores along with timestamps for each entity.",
            "dependencies": [
              4
            ],
            "details": "Ensure the database can efficiently store, retrieve, and update scores, and that each score entry is associated with a precise calculation timestamp for auditability.",
            "status": "done",
            "testStrategy": "Test database operations for storing, retrieving, and updating scores, and confirm timestamp accuracy and integrity."
          }
        ]
      },
      {
        "id": 5,
        "title": "Company Discovery Interface with Search and Filtering",
        "description": "Build main company discovery interface with ranked display, search, and basic filtering capabilities",
        "details": "Create responsive company discovery page showing all AI companies ranked by spearfish score. Implement company cards with key metrics (score, batch, team size, growth indicators). Add text search across names, descriptions, and industries. Build filtering system for batch, team size, and hiring status. Implement semantic search using OpenAI embeddings for better query understanding. Add pagination and infinite scroll for performance.",
        "testStrategy": "Test search functionality with various queries, validate filtering combinations, test performance with large datasets, verify responsive design across devices",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Responsive Company Discovery Page Layout",
            "description": "Create a responsive layout for the company discovery interface that adapts seamlessly across devices and screen sizes.",
            "dependencies": [],
            "details": "Apply user-centered and cross-platform design principles to ensure the interface is visually appealing and functional on desktop and mobile. Incorporate branding and visual identity elements for consistency.",
            "status": "done",
            "testStrategy": "Test layout responsiveness using multiple device simulators and browsers; validate visual consistency and usability."
          },
          {
            "id": 2,
            "title": "Implement Ranked Company Cards with Key Metrics",
            "description": "Develop company cards that display essential metrics such as spearfish score, batch, team size, and growth indicators, and ensure companies are ranked accordingly.",
            "dependencies": [
              1
            ],
            "details": "Design and build reusable card components that clearly present all required data. Ensure ranking logic is applied to the display order.",
            "status": "done",
            "testStrategy": "Verify that all metrics are displayed correctly and that companies are ranked as expected; conduct usability testing for clarity."
          },
          {
            "id": 3,
            "title": "Develop Text and Semantic Search Functionality",
            "description": "Enable users to search companies by name, description, and industry using both traditional text search and semantic search powered by OpenAI embeddings.",
            "dependencies": [
              2
            ],
            "details": "Integrate a search bar supporting keyword queries and semantic understanding for improved relevance. Ensure search results update dynamically.",
            "status": "done",
            "testStrategy": "Test search accuracy with a variety of queries; compare semantic and text search results for relevance and performance."
          },
          {
            "id": 4,
            "title": "Build Filtering System for Batch, Team Size, and Hiring Status",
            "description": "Implement interactive filters allowing users to refine company results by batch, team size, and hiring status.",
            "dependencies": [
              3
            ],
            "details": "Design filter UI components and connect them to the data layer to update results in real time. Ensure filters are intuitive and accessible.",
            "status": "done",
            "testStrategy": "Test filter combinations for correct result updates; validate accessibility and ease of use through user feedback."
          },
          {
            "id": 5,
            "title": "Add Pagination and Infinite Scroll for Performance",
            "description": "Integrate pagination and infinite scroll mechanisms to efficiently load and display large sets of company data.",
            "dependencies": [
              4
            ],
            "details": "Choose and implement a loading strategy (pagination or infinite scroll) that maintains performance and user experience for large datasets.",
            "status": "done",
            "testStrategy": "Test loading performance with large datasets; ensure smooth scrolling and correct data loading without duplication or missing entries."
          }
        ]
      },
      {
        "id": 6,
        "title": "Company Profile Pages with Detailed Intelligence",
        "description": "Create comprehensive company profile pages displaying real YC data, scores, and spearfish analysis from backend services",
        "status": "done",
        "dependencies": [
          5
        ],
        "priority": "medium",
        "details": "Build detailed company profile pages with tabbed organization (Overview, Technical, Team, Opportunities). Display real YC data from API service, spearfish score breakdown from scoring algorithm, GitHub repository information, and growth metrics from Supabase. Create 'Why Spearfish This Company' section highlighting specific signals and opportunities. Replace all mock data with actual API calls. Add dynamic content loading and caching for performance. Implement breadcrumb navigation and social sharing.",
        "testStrategy": "Test profile page loading performance with real data, validate data accuracy from backend services, test tab navigation and content organization, verify score explanations match algorithm output, test API integration and error handling",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Tabbed Company Profile Page Layout",
            "description": "Create the structural layout for company profile pages with tabbed navigation for Overview, Technical, Team, and Opportunities sections.",
            "dependencies": [],
            "details": "Develop a responsive UI/UX design that organizes company data into clearly separated tabs, ensuring intuitive navigation and accessibility.",
            "status": "done",
            "testStrategy": "Verify tab switching, layout responsiveness, and accessibility compliance across devices and browsers."
          },
          {
            "id": 2,
            "title": "Integrate YC Data and Growth Metrics",
            "description": "Fetch and display Y Combinator (YC) company data and relevant growth metrics within the Overview and Opportunities tabs.",
            "dependencies": [
              1
            ],
            "details": "Implement backend and frontend logic to retrieve YC data and growth statistics, presenting them in a visually clear and informative manner.",
            "status": "done",
            "testStrategy": "Test data retrieval accuracy, loading times, and correct rendering of all YC and growth metric fields."
          },
          {
            "id": 3,
            "title": "Replace Mock Data with Real API Integration",
            "description": "Remove all mock data from CompanyCard, CompanyProfileClient, and tab components, replacing with actual API calls to backend services.",
            "dependencies": [
              2
            ],
            "details": "Update CompanyCard to fetch data from Supabase companies table. Modify CompanyProfileClient to retrieve real company data via API routes. Update OverviewTab to display actual YC data from the YC API service. Ensure all components handle loading states and API errors gracefully.",
            "status": "done",
            "testStrategy": "Test API calls return correct data, verify error handling for failed requests, validate loading states display properly, ensure data matches what's in Supabase and YC API."
          },
          {
            "id": 4,
            "title": "Implement Spearfish Score Breakdown and Explanations",
            "description": "Display the real spearfish score from the scoring algorithm with a detailed breakdown and contextual explanations in the Technical tab.",
            "dependencies": [
              3
            ],
            "details": "Connect to the spearfish scoring algorithm service to fetch actual scores and breakdowns. Develop components to show score components, calculation logic from the algorithm, and explanatory tooltips or modals for user understanding. Replace mock score data with real algorithm outputs.",
            "status": "done",
            "testStrategy": "Validate score calculations match algorithm output, breakdown accuracy against scoring service, and clarity of explanations through user testing."
          },
          {
            "id": 5,
            "title": "Add GitHub Repository and Team Information",
            "description": "Integrate GitHub repository data and detailed team member profiles into the Technical and Team tabs using real API data.",
            "dependencies": [
              3
            ],
            "details": "Connect to GitHub APIs and Supabase to display real repository stats and activity. Present structured team bios, roles, and relevant links from actual company data. Remove hardcoded team information and replace with dynamic data from backend services.",
            "status": "done",
            "testStrategy": "Check for correct API integration, data freshness from GitHub, completeness of team information from Supabase, and proper error handling for missing data."
          },
          {
            "id": 6,
            "title": "Implement Dynamic Content Loading, Caching, and Navigation Features",
            "description": "Enable dynamic content loading with real data, caching for performance, breadcrumb navigation, social sharing, and the 'Why Spearfish This Company' section using actual insights.",
            "dependencies": [
              4,
              5
            ],
            "details": "Optimize data fetching from all backend services with caching strategies. Add breadcrumb trails for navigation, integrate social sharing buttons with real company data, and create a section highlighting key signals and opportunities based on actual scoring algorithm outputs and company data.",
            "status": "done",
            "testStrategy": "Test dynamic loading speed with real API calls, cache invalidation for updated data, navigation accuracy, social sharing with actual company info, and relevance of the 'Why Spearfish' content based on real scores."
          }
        ]
      },
      {
        "id": 7,
        "title": "GitHub API Integration for Technical Signals",
        "description": "Integrate GitHub API to track repository activity and star growth for enhanced company scoring, replacing mock GitHub data in frontend",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "details": "Build GitHub API integration to fetch repository data for AI companies. Track star counts, commit activity, and growth metrics. Implement monthly star growth calculation (>1K/month criteria). Create background jobs for daily GitHub data updates with proper rate limiting (5000 requests/hour). Store historical data for trend analysis in Supabase. Handle API errors and missing repositories gracefully. Update frontend components to use real GitHub data instead of mock values.",
        "testStrategy": "Test GitHub API integration and rate limiting, validate star growth calculations, test background job execution, verify error handling for private/missing repositories, ensure frontend displays real GitHub metrics",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up GitHub API Client and Authentication",
            "description": "Create GitHub API client with proper authentication and rate limiting handling.",
            "dependencies": [],
            "details": "Implement GitHub API client using Octokit or similar library. Set up authentication with GitHub API tokens. Implement rate limiting logic to stay within 5000 requests/hour limit. Create error handling for API failures.",
            "status": "done",
            "testStrategy": "Test API authentication, verify rate limiting works correctly, test error handling scenarios."
          },
          {
            "id": 2,
            "title": "Create Data Models and Database Schema for GitHub Data",
            "description": "Design and implement Supabase tables for storing GitHub repository data and historical metrics.",
            "dependencies": [
              1
            ],
            "details": "Create tables for repository information, star history, commit activity, and growth metrics. Design schema to support efficient queries and trend analysis. Set up indexes for performance.",
            "status": "done",
            "testStrategy": "Verify database schema creation, test data insertion and retrieval, validate query performance."
          },
          {
            "id": 3,
            "title": "Implement Repository Data Fetching and Storage",
            "description": "Build service to fetch repository data from GitHub API and store in Supabase.",
            "dependencies": [
              2
            ],
            "details": "Create functions to fetch repository stats, star counts, and commit activity. Implement data transformation and storage logic. Handle missing or private repositories gracefully.",
            "status": "done",
            "testStrategy": "Test data fetching accuracy, verify proper storage in database, test error handling for edge cases."
          },
          {
            "id": 4,
            "title": "Build Background Jobs for Daily Updates",
            "description": "Create scheduled jobs to update GitHub data daily with proper queuing and error recovery.",
            "dependencies": [
              3
            ],
            "details": "Implement background job system using Supabase Edge Functions or similar. Schedule daily updates for all tracked repositories. Add retry logic and error notifications. Implement job queuing to respect rate limits.",
            "status": "done",
            "testStrategy": "Test job scheduling and execution, verify rate limit compliance, test error recovery and retry logic."
          },
          {
            "id": 5,
            "title": "Replace Mock GitHub Data in Frontend Components",
            "description": "Update all frontend components to fetch and display real GitHub data from the API service.",
            "dependencies": [
              3
            ],
            "details": "Modify CompanyCard to show real star counts and growth. Update Technical tab to display actual repository metrics. Remove all hardcoded GitHub data. Implement loading states and error handling in UI.",
            "status": "done",
            "testStrategy": "Verify frontend displays correct GitHub data, test loading and error states, validate data freshness indicators."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Deep Research for Company",
        "description": "The deep research is looking for actionable intelligence that enables value-first outreach. It analyzes the company's technical challenges (GitHub issues, performance bottlenecks, scaling problems), recent activities (product launches, blog posts, hiring patterns), team dynamics (key decision makers, their interests and pain points), and business context (growth stage pressures, competitive positioning, immediate needs). The goal is to identify specific problems the company is facing that the user can solve through artifacts - whether that's fixing a bug in their open-source repo, building a dashboard for their data needs, optimizing their ML pipeline, or creating a market analysis for their expansion plans. This research transforms the user from \"another job applicant\" into \"someone who understands our problems and has already started solving them.\"",
        "status": "pending",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "details": "Build comprehensive deep research system that analyzes multiple data sources to identify actionable intelligence about target companies. Implement GitHub issue analysis to find technical challenges and pain points. Create web scraping and API integration to track recent company activities including product launches, blog posts, and hiring patterns. Build team analysis system to identify key decision makers and their professional interests. Implement business context analysis including growth stage assessment, competitive positioning, and immediate needs identification. Create intelligence synthesis system that connects identified problems to potential user solutions and artifact opportunities.",
        "testStrategy": "Test deep research accuracy with real company data, validate problem identification against actual company challenges, test intelligence synthesis produces actionable insights, verify research transforms generic outreach into targeted value propositions",
        "subtasks": [
          {
            "id": 6,
            "title": "Create Spear This! Tab",
            "description": "Create a new dedicated tab called 'Spear This!' with deep research functionality and results display.",
            "status": "done",
            "dependencies": [
              5
            ],
            "details": "Create a new SpearThisTab component as a dedicated tab for all deep research functionality. Integrate the tab into the company page's navigation system alongside Overview, Team, and Opportunities tabs. Add 'Start Deep Research' button with research type selection options. Create ResearchProgress component for real-time status updates with progress bar. Build ResearchResults component to display categorized findings with citations. Add research history section with ability to view previous sessions. Implement research freshness indicators and refresh functionality. Ensure the tab follows existing tab patterns for consistency and includes appropriate iconography to indicate its research/analysis purpose.\n<info added on 2025-07-16T21:57:22.122Z>\nThe UI implementation will be restructured to create a new dedicated tab called \"Spear This!\" instead of modifying the existing OpportunitiesTab. This tab will serve as the central hub for all deep research functionality. The implementation involves creating a new SpearThisTab component that will be integrated into the company page's tab navigation system alongside Overview, Team, and Opportunities tabs. The SpearThisTab will house all research-related components including the research initiation controls, progress tracking, results display, and historical research data. The tab's navigation entry should be prominently placed and include appropriate iconography to indicate its research/analysis purpose. The component structure will follow the existing tab patterns in the codebase for consistency.\n</info added on 2025-07-16T21:57:22.122Z>",
            "testStrategy": "Test UI components render correctly, verify real-time updates work, test user interactions and error states, validate responsive design across devices."
          },
          {
            "id": 7,
            "title": "Implement Caching and Optimization",
            "description": "Build caching system to optimize API usage and improve performance while maintaining data freshness.",
            "status": "pending",
            "dependencies": [
              4,
              5
            ],
            "details": "Create research result caching with 7-14 day expiration based on data type. Implement incremental update mechanism for recent company activities. Add cost monitoring with budget alerts and usage analytics. Build intelligent cache invalidation based on company profile updates. Create user-triggered refresh with cost warnings.",
            "testStrategy": "Test cache hit/miss scenarios, verify expiration logic works correctly, test incremental updates accuracy, validate cost tracking and alerts."
          },
          {
            "id": 8,
            "title": "Add Error Handling and Resilience",
            "description": "Implement comprehensive error handling and recovery mechanisms for production reliability.",
            "status": "pending",
            "dependencies": [
              4,
              5,
              6
            ],
            "details": "Implement retry logic with exponential backoff for transient failures. Create fallback strategies when Perplexity API is unavailable. Add session recovery to resume interrupted research. Build comprehensive error logging and monitoring. Implement graceful degradation with partial results display.",
            "testStrategy": "Test various failure scenarios, verify retry mechanisms work correctly, test session recovery after interruptions, validate error messages are user-friendly."
          },
          {
            "id": 1,
            "title": "Create Database Schema for Research Sessions",
            "description": "Design and implement database tables for storing company research sessions and findings from Perplexity API.",
            "dependencies": [],
            "details": "Create migration files for company_research_sessions table with fields for session tracking, status, and cost monitoring. Create research_findings table to store structured research results with citations. Add proper indexes for performance and implement RLS policies for secure access control.\n<info added on 2025-07-16T20:51:05.803Z>\nMigration successfully implemented in 20250116_create_research_sessions_tables.sql. The implementation includes company_research_sessions table for tracking API calls with comprehensive cost monitoring (per-call costs, cumulative costs), status tracking (pending/processing/completed/failed), and metadata storage. The research_findings table stores structured results with full citation support, confidence scoring, and verification timestamps. Both tables feature optimized indexes on company_id, created_at, and status fields for efficient querying. Row Level Security policies ensure data isolation between organizations with SELECT/INSERT/UPDATE/DELETE permissions properly scoped to organization members. Field validation includes CHECK constraints for valid status values, positive cost amounts, and confidence scores between 0-1. The schema architecture supports extensibility for multiple research types (market analysis, competitor research, technology stack discovery) through the research_type enum and flexible JSONB metadata fields.\n</info added on 2025-07-16T20:51:05.803Z>\n<info added on 2025-07-16T21:20:37.041Z>\nFixed migration conflict by creating safe migration file (20250116_create_research_sessions_tables_safe.sql) that uses CREATE TABLE IF NOT EXISTS and adds missing columns conditionally. The new migration handles existing tables gracefully, adds missing columns only if they don't exist, creates indexes safely, and sets up RLS policies correctly. This resolves the 'relation already exists' error and ensures the schema is properly updated regardless of existing state.\n</info added on 2025-07-16T21:20:37.041Z>",
            "status": "done",
            "testStrategy": "Test table creation with migration rollback capability, verify RLS policies work correctly, validate foreign key relationships and constraints."
          },
          {
            "id": 2,
            "title": "Set Up Perplexity API Integration",
            "description": "Create Perplexity service with Sonar Deep Research API integration and authentication.",
            "dependencies": [],
            "details": "Install Perplexity SDK dependencies (@perplexity-ai/sdk or fetch-based implementation). Create perplexity-research-service.ts with API client setup and configuration. Add PERPLEXITY_API_KEY to environment variables. Implement error handling, rate limiting, and retry logic for API calls.\n<info added on 2025-07-16T21:00:58.195Z>\nSuccessfully integrated Perplexity API with sonar-pro model configuration. The implementation includes a comprehensive service architecture featuring rate limiting (3 requests per second), exponential backoff retry logic, and robust error handling. Created specialized research methods: performDeepResearch for comprehensive company analysis, performTechnicalAnalysis for technology stack discovery, performCompetitiveAnalysis for competitor insights, and performMarketAnalysis for industry trends. Added cost tracking functionality to monitor API usage and implemented health check endpoints to verify service availability. All unit tests are passing and the API is responding normally in both development and production environments.\n</info added on 2025-07-16T21:00:58.195Z>",
            "status": "done",
            "testStrategy": "Test API connection with sample queries, verify authentication works, test error handling for various failure scenarios, validate rate limiting behavior."
          },
          {
            "id": 3,
            "title": "Build Research Query Templates",
            "description": "Create structured query templates for different types of company intelligence gathering.",
            "dependencies": [
              2
            ],
            "details": "Design technical intelligence queries to find GitHub issues, performance bottlenecks, and scaling problems. Create business context queries for product launches, funding, and hiring patterns. Build team dynamics queries to identify key decision makers and their pain points. Develop competitive analysis queries for market positioning insights.\n<info added on 2025-07-16T21:07:18.299Z>\nCreated comprehensive research query template system with 9 specialized templates organized into 6 categories:\n\nTechnical Intelligence Templates:\n- Technical challenges template for identifying GitHub issues, performance problems, and scaling bottlenecks\n- Technology stack analysis template for understanding infrastructure and architectural decisions\n\nBusiness Context Templates:\n- Business challenges template for uncovering operational pain points and growth obstacles\n- Market position template for competitive landscape analysis\n- Funding & growth template for investment history and expansion patterns\n\nTeam & Decision Maker Templates:\n- Key decision makers template for identifying CTOs, VPs of Engineering, and technical leadership\n- Team dynamics template for understanding organizational structure and hiring patterns\n\nCompetitive & Market Templates:\n- Competitor analysis template for direct and indirect competition insights\n- Industry trends template for market direction and emerging technologies\n\nTemplate Processing Features:\n- Dynamic variable substitution system supporting company name, domain, industry, and custom parameters\n- Built-in validation for required variables and template structure\n- Customization options for search domains, date ranges, and result formatting\n- Recency filters with support for past week/month/quarter/year timeframes\n- Expected output specifications for each template type\n\nHigh-priority templates (technical challenges, business challenges, key decision makers) fully implemented and tested with live variable substitution. System successfully processes templates with proper parameter replacement and generates targeted research queries for Perplexity API integration.\n</info added on 2025-07-16T21:07:18.299Z>",
            "status": "done",
            "testStrategy": "Test query templates with sample companies, verify query outputs contain expected information types, validate citation quality and relevance."
          },
          {
            "id": 4,
            "title": "Implement Core Research Service",
            "description": "Build the main research orchestration service that coordinates Perplexity API calls and manages research sessions.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create methods for starting research sessions with progress tracking. Implement parallel research execution for different intelligence types. Build cost calculation and optimization logic to manage API expenses. Add research result synthesis to combine findings from multiple queries. Implement session state management and recovery mechanisms.\n<info added on 2025-07-16T21:18:31.133Z>\nThe core research service implementation is complete with full session orchestration capabilities. The service architecture includes a ResearchSession class that manages unique session IDs and tracks progress across multiple parallel queries. Progress tracking provides real-time percentage updates and status messages to the UI through callback mechanisms.\n\nParallel query execution is managed through a queue system with configurable concurrency limits, allowing simultaneous research across different intelligence types while preventing API rate limit issues. The cost calculation system tracks token usage and API calls, providing real-time cost estimates and implementing optimization strategies to stay within budget constraints.\n\nResult synthesis combines findings from multiple Perplexity queries into cohesive, actionable insights. The synthesis process identifies patterns across different intelligence types, extracts key opportunities, and generates executive summaries with specific recommended next steps. Each finding is categorized by impact level and includes supporting evidence from the research.\n\nSession state is persisted to the database, enabling recovery from interruptions and allowing users to resume research sessions. The implementation includes comprehensive error handling with retry logic for transient failures, graceful degradation when specific queries fail, and detailed error reporting for debugging.\n\nThe service successfully integrates with the Perplexity API through the PerplexityResearchService class, processing raw API responses into structured CompanyIntelligence objects. The implementation follows TypeScript best practices with full type safety and includes extensive logging for monitoring and debugging purposes.\n</info added on 2025-07-16T21:18:31.133Z>",
            "status": "done",
            "testStrategy": "Test research orchestration with multiple query types, verify progress tracking updates correctly, test cost calculations accuracy, validate session recovery after failures."
          },
          {
            "id": 5,
            "title": "Create Research API Endpoints",
            "description": "Build REST API endpoints for initiating and managing company research sessions.",
            "dependencies": [
              4
            ],
            "details": "Implement POST /api/companies/[id]/research/start to initiate deep research with configurable research types. Create GET /api/companies/[id]/research/[sessionId]/progress for real-time status updates. Build GET /api/companies/[id]/research/[sessionId]/results to retrieve structured findings. Add GET /api/companies/[id]/research/history for viewing past research sessions.\n<info added on 2025-07-16T21:25:05.485Z>\nThe research API endpoints have been fully implemented with production-ready features. Authentication is handled through Clerk middleware on all endpoints. Request validation uses Zod schemas for type safety and input sanitization. The POST endpoint accepts customizable research templates with variable substitution for dynamic queries. Progress tracking includes detailed statistics like total queries, completed queries, and estimated time remaining. Results endpoint supports advanced filtering by research type, date range, and custom metadata fields, with built-in pagination for large result sets. History endpoint provides comprehensive filtering options including date ranges, research types, and completion status. All endpoints include proper error handling with standardized error responses and status codes. Test endpoints have been created for each main endpoint to facilitate development and debugging, located at /api/test-research-endpoints with mock data generation and simulated async operations.\n</info added on 2025-07-16T21:25:05.485Z>",
            "status": "done",
            "testStrategy": "Test API endpoints with various request scenarios, verify authentication and authorization, test error responses, validate data validation and sanitization."
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Agent Architecture with Project Idea Generator and Email Template Creator Tools",
        "description": "Create the core agent system with AI-powered tools for artifact generation and email creation",
        "status": "pending",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "details": "Build intelligent agent architecture that transforms deep research findings into targeted solution artifacts and personalized outreach emails. Create agent orchestration system that coordinates between two specialized tools: Tool 1 (Project Idea Generator) analyzes research findings to identify problems and generate solution artifacts (technical proposals, integration guides, optimization plans), and Tool 2 (Email Template Creator) takes solution artifacts and creates personalized outreach emails. Implement agent state management, tool communication protocols, API integration with OpenAI/Claude, artifact categorization, prioritization logic, and email personalization engine. Create API endpoints for frontend integration.",
        "testStrategy": "Test agent tool coordination, verify AI integration works correctly, validate artifact generation quality and email personalization accuracy, test API endpoints functionality",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Agent Architecture and Tool Interface Specifications",
            "description": "Create the foundational architecture for the agent system with clear tool specifications.",
            "dependencies": [],
            "details": "Design agent orchestration system architecture. Define tool interface specifications with input/output schemas for Project Idea Generator and Email Template Creator. Create agent state management design. Plan tool communication protocols and data flow between tools. Design integration points with existing research data structures.",
            "status": "pending",
            "testStrategy": "Verify architecture design supports tool coordination, validate interface specifications completeness, test design scalability."
          },
          {
            "id": 2,
            "title": "Implement Project Idea Generator Tool",
            "description": "Build Tool 1 that analyzes research findings and generates targeted solution artifacts.",
            "dependencies": [
              1
            ],
            "details": "Implement artifact generation logic that processes research findings and identifies specific problems. Build solution artifact creation for technical proposals, integration guides, and optimization plans. Create prioritization system using confidence scores and priority levels from research data. Implement artifact categorization system for different solution types. Add AI integration for intelligent problem-solution matching.",
            "status": "pending",
            "testStrategy": "Test problem identification accuracy, verify artifact generation quality, validate prioritization system effectiveness, test AI integration."
          },
          {
            "id": 3,
            "title": "Implement Email Template Creator Tool",
            "description": "Build Tool 2 that creates personalized outreach emails based on generated artifacts.",
            "dependencies": [
              2
            ],
            "details": "Create email generation system that takes solution artifacts and produces personalized outreach content. Implement research finding integration to demonstrate company understanding. Build template personalization engine with specific problem references and solution explanations. Create email structure optimization for impact and engagement. Add customization options for tone and technical depth.",
            "status": "pending",
            "testStrategy": "Test email personalization accuracy, verify research finding integration, validate template quality and engagement potential."
          },
          {
            "id": 4,
            "title": "Create Agent API Endpoints and Integration Layer",
            "description": "Build API endpoints that connect the agent system to the frontend interface.",
            "dependencies": [
              3
            ],
            "details": "Create /api/companies/[id]/artifacts/generate endpoint for artifact generation. Build /api/companies/[id]/artifacts/[id]/email endpoint for email template creation. Implement ArtifactGenerationService that interfaces with research data. Add artifact traceability linking back to specific research findings. Create error handling and validation for API requests.",
            "status": "pending",
            "testStrategy": "Test API endpoints functionality, verify data flow from research to artifacts to emails, validate error handling and edge cases."
          }
        ]
      },
      {
        "id": 10,
        "title": "Build User Interface Flow for Artifact Generation and Email Creation",
        "description": "Create complete UI experience for the artifact generation and email creation workflow",
        "status": "pending",
        "dependencies": [
          9
        ],
        "priority": "medium",
        "details": "Implement complete user experience flow: 1) User generates deep research report for target company, 2) User clicks 'Generate Artifacts' button to create project ideas based on identified company problems, 3) User selects which project they completed, 4) System generates personalized email template for outreach. Build UI flow in Spear This! tab with progressive disclosure: research results → artifact generation button → project selection interface → email template output. Create seamless workflow from research insights to actionable outreach materials with smooth transitions and state management.",
        "testStrategy": "Test complete user journey, verify all steps flow smoothly, validate state persistence and navigation works correctly, test responsive design",
        "subtasks": [
          {
            "id": 1,
            "title": "Add 'Generate Artifacts' Button to Research Results",
            "description": "Add artifact generation button that appears after research completion in Spear This! tab.",
            "dependencies": [],
            "details": "Add 'Generate Artifacts' button that appears after research completion. Position button prominently in research results section. Implement button state management (disabled/enabled based on research status). Add loading states and visual feedback during artifact generation. Connect button to agent API endpoints.",
            "status": "pending",
            "testStrategy": "Test button placement and visibility, verify button states work correctly, validate API integration."
          },
          {
            "id": 2,
            "title": "Build Project Ideas Display Component",
            "description": "Create UI component for displaying generated project ideas with clear problem-solution mapping.",
            "dependencies": [
              1
            ],
            "details": "Create project ideas display component showing generated solutions with problem-solution mapping. Design project card layout with clear descriptions, difficulty levels, and impact potential. Implement expandable cards for detailed information. Add visual indicators for different artifact types (technical proposals, integration guides, optimization plans).",
            "status": "pending",
            "testStrategy": "Test project ideas display correctly, verify card interactions work, validate responsive design across devices."
          },
          {
            "id": 3,
            "title": "Implement Project Selection Interface",
            "description": "Create interface for users to select which project they've completed from the generated ideas.",
            "dependencies": [
              2
            ],
            "details": "Build project selection UI with radio buttons or checkboxes for project completion status. Add project details modal for more information. Create completion confirmation flow with progress tracking. Implement validation to ensure user selects completed project before proceeding. Add visual feedback for selected projects.",
            "status": "pending",
            "testStrategy": "Test project selection flow, verify completion tracking works, validate user can't proceed without selection."
          },
          {
            "id": 4,
            "title": "Build Email Template Generation and Preview Interface",
            "description": "Create UI for email template generation, preview, and customization.",
            "dependencies": [
              3
            ],
            "details": "Create email generation interface that calls agent API with selected project. Build email preview component with subject line, body content, and call-to-action display. Implement template customization options for tone and technical depth. Add copy-to-clipboard functionality and export options. Create email editing capabilities for final touches.",
            "status": "pending",
            "testStrategy": "Test email generation triggers correctly, verify preview displays accurately, validate customization options work."
          },
          {
            "id": 5,
            "title": "Implement Complete User Flow with Progressive Disclosure",
            "description": "Connect all components into seamless workflow with navigation and state management.",
            "dependencies": [
              4
            ],
            "details": "Implement step-by-step user flow: research results → generate artifacts button → project ideas list → project selection → email template output. Add progress indicators and breadcrumb navigation. Create smooth transitions between each step. Implement back/forward navigation and state persistence. Add workflow restart capabilities.",
            "status": "pending",
            "testStrategy": "Test complete user journey end-to-end, verify all steps flow smoothly, validate state persistence and navigation works correctly."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-11T03:44:57.583Z",
      "updated": "2025-07-17T01:10:47.723Z",
      "description": "Tasks for master context"
    }
  }
}